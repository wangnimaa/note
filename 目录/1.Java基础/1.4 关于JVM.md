1.Heap(堆区)

Heap是OOM主要的产生地，它存储着几乎所有的实例对象，堆由垃圾收集器自动进行回收，堆区由各子线程共享使用。它所占用的空间是所有内存区域中最大的。

堆分为两部分：新生代和老年代。对象产生之初在新生代，步入末期时进入老年代。但老年代也接收在新生代无法容纳的超大对象。新生代分为1个Eden区，2个
Surrvivor区。绝大部分对象在Eden区生成，当Eden区装满的时候，会自动触发Young Garbage Collection,即YGC。当垃圾回收的时候，在Eden区实现清除策
略，没有被引用的对象直接回收。依然存活的对象会被移送到surrvivor区。surrvivor区分为S0和S1两块内存空间，每次YGC的时候，它们将存活的对象复制到
未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果YGC要移送的对象大于Surrvivor区容量的上限，则直接移交到老年代。
每个对象都有一个计数器，每次YGC都会加1，当计算器的值到达配置的某个阀值时，直接移交到老年代。如果Surrvivor区无法放下，或者超大对象的阈值超过上
限，则尝试在老年代中进行分配；如果老年代也无法放下，则会触发Full Garbage Collection，即FGC。如果依然无法放下，则抛出OOM。堆内存出现OOM的概率
是所有内存耗尽异常中最高的。
在不同的JVM实现及不同的回收机制中，堆内存的划分方式是不一样的。

2.元数据区

JDK8中，元空间的前身Perm区已经被淘汰。在JDK7及之前的版本中，只有Hostspot才有Perm区，译为永久代，它在启动时固定大小，很难进行调优，并且FGC时会
移动类元信息。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。
区别于永久代，元空间在本地内存中分配。在JDK8里，Perm区中的所有内容中字符串常量移至堆内存，其它内容包括类元信息，字段，静态属性，方法，常量等都
移动至元空间内。

3.JVM Stack（虚拟机栈）

栈（Stack）是一个先进先出的数据结构。

相对于基于寄存器的运行环境来说，JVM是基于栈结构的运行环境。栈结构移植性更好，可控性更强。JVM中的虚拟机栈是描述Java方法执行的内存区域，他是线程
私有的。栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程，就是栈帧从入栈到出栈的过程。在活动线程中，只有位于栈顶的栈帧
才是有效的，称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而StackOverflowError表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。虚拟机通过压栈和出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法
正常执行结束，肯定会跳转到另一个栈帧上。在执行的过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。栈帧在整个JVM体系中的地位颇高，
包括局部变量表，操作栈，动态连接，方法返回地址等。

(1)局部变量表

局部变量表是存放方法参数和局部变量的区域。相对于类属性变量的准备阶段和初始化阶段来说，局部变量没有准备阶段，必须显示初始化。如果是非静态方法，则
在index[0]位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量。字节码指令中的STORE指令就是将操作栈中计算完成的局部变量写回局部变量
表的存储空间内。

(2)操作栈

操作栈是一个初始状态为空的桶式结构栈。在方法执行过程中，会有各种指令往栈中写入和提取信息。JVM的执行引擎是基于栈的执行引擎，其中的栈指的就是操作
栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的stack属性中。

(3)动态连接

每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态连接

(4)方法返回地址

方法执行时有两种退出情况：第一，正常退出，即正常执行到任何方法的返回字节码指令，如return，ireturn，areturn等；第二，异常退出。无论何种退出情
况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：
    返回值压入上层调用栈帧。
    异常信息抛给能够处理的栈帧。
    PC计数器指向方法调用后的下一条指令。
    
4.Native Method Stacks(本地方法栈)

本地方法栈在JVM内存布局中，也是线程对象私有的，但是虚拟机栈“主内”，而本地方法栈“主外”。这个“内外”是针对JVM来说的，本地方法栈为native方法服务。
线程开始调用本地方法时，会进入一个不在受JVM约束的世界。本地方法可以通过JNI（Java Native Interface）来访问虚拟机运行时的数据区，甚至可以调用
寄存器，具有和JVM相同的能力和权限。当大量本地方法出现时，势必会削弱JVM对系统的控制力，因为它的出错信息都比较黑盒。对于内存不足的情况，本地方
法栈还是会native heap OutOfMemory。
重点说一下JNI类本地方法，最著名的本地方法应该是System.currentTimeMillis(),JNI使Java深度使用操作系统的特性功能，复用非Java代码。但是在项目
过程中，如果大量使用其它语言来实现JNI，就会丧失跨平台特性，威胁到程序运行的稳定性。

5.Program Counter Register（程序计数寄存器）

每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和信号指示器等，线程执行或恢复都要依赖程序计数器。程序计数
器在各个线程之间互不影响，此区域也不会发生内存溢出异常。从线程共享的角度来看，堆和元空间是所有线程共享的，而虚拟机栈，本地方法栈，程序计数器是
线程内部私有的。


