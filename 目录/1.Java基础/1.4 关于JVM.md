1.Heap(堆区)

Heap是OOM主要的产生地，它存储着几乎所有的实例对象，堆由垃圾收集器自动进行回收，堆区由各子线程共享使用。它所占用的空间是所有内存区域中最大的。

堆分为两部分：新生代和老年代。对象产生之初在新生代，步入末期时进入老年代。但老年代也接收在新生代无法容纳的超大对象。新生代分为1个Eden区，2个
Surrvivor区。绝大部分对象在Eden区生成，当Eden区装满的时候，会自动触发Young Garbage Collection,即YGC。当垃圾回收的时候，在Eden区实现清除策
略，没有被引用的对象直接回收。依然存活的对象会被移送到surrvivor区。surrvivor区分为S0和S1两块内存空间，每次YGC的时候，它们将存活的对象复制到
未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果YGC要移送的对象大于Surrvivor区容量的上限，则直接移交到老年代。
每个对象都有一个计数器，每次YGC都会加1，当计算器的值到达配置的某个阀值时，直接移交到老年代。如果Surrvivor区无法放下，或者超大对象的阈值超过上
限，则尝试在老年代中进行分配；如果老年代也无法放下，则会触发Full Garbage Collection，即FGC。如果依然无法放下，则抛出OOM。堆内存出现OOM的概率
是所有内存耗尽异常中最高的。
在不同的JVM实现及不同的回收机制中，堆内存的划分方式是不一样的。

2.元数据区

JDK8中，元空间的前身Perm区已经被淘汰。在JDK7及之前的版本中，只有Hostspot才有Perm区，译为永久代，它在启动时固定大小，很难进行调优，并且FGC时会
移动类元信息。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。
区别于永久代，元空间在本地内存中分配。在JDK8里，Perm区中的所有内容中字符串常量移至堆内存，其它内容包括类元信息，字段，静态属性，方法，常量等都
移动至元空间内。

3.JVM Stack（虚拟机栈）

栈（Stack）是一个先进先出的数据结构。

相对于基于寄存器的运行环境来说，JVM是基于栈结构的运行环境。栈结构移植性更好，可控性更强。JVM中的虚拟机栈是描述Java方法执行的内存区域，他是线程
私有的。栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程，就是栈帧从入栈到出栈的过程。在活动线程中，只有位于栈顶的栈帧
才是有效的，称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而StackOverflowError表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。虚拟机通过压栈和出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法
正常执行结束，肯定会跳转到另一个栈帧上。在执行的过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。栈帧在整个JVM体系中的地位颇高，
包括局部变量表，操作栈，动态连接，方法返回地址等。
