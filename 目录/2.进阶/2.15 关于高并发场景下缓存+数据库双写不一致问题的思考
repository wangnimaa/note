问题
如果是先修改数据库，再删除缓存的方案，会有问题，试想，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，出现数据不一致的情况。
解决思路
反过来，先删除缓存，再修改数据库。读缓存读不到，查数据库更新缓存的时候就拿到了最新的库存数据。如果删除缓存成功了，而修改数据库失败了，那么数据
库中依旧是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。

当库存数据发生了变更，我们先删除了缓存，然后要去修改数据库。
设想一下，如果这个时候修改数据库的操作还没来及完成，突然一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。
数据变更的操作完成后数据库的库存被修改成了新值，但缓存中又变成了旧数据。那么这个时候是不是还会出现缓存和数据库不一致的情况？

个人的思考：更新数据库和缓存的时候加入分布式锁，读取缓存为空的时候尝试获取锁，获取不到就等待，获取到读取数据库，更新缓存。
