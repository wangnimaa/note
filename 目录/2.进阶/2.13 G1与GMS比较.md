G1回收阶段

初始标记
并发标记
最终标记（并发）
筛选回收（并发）

CMS回收阶段

初始标记
并发标记
重新标记
并发清除

CMS和G1的相同部分

初始标记都需要停顿，即不能与用户线程并行，需要Stop The Wrold。都是标记能与GC Roots直接关联的对象
并发标记可以与用户线程一起，即不需要停顿。并发标记主要是沿着GC Reference Chain进行对象可达性分析的过程。

CMS和G1的不同点

CMS的并发回收是与用户线程一起进行的，不需要停顿。如果有垃圾是在标记过程后产生的，那么就会产生一个回收不彻底的问题。设想一下一边打扫房间，
一边有人在那扔垃圾，那么最后的打扫效果是不是不好？而G1的筛选回收是需要暂停用户线程，但是是并发回收的，所以速度快，而且回收效率高。
CMS的回收器不可以对young generation回收，只能对old generation回收。因此需要与其他收集器配合，比如ParNew或者Serial。而G1无论是young
还是old都可以回收，人家可以独立管理整个java堆。而且回收算法是采用的标记整理（局部是复制清除算法，因为young generation中采用复制清除效率更高）
，不会产生内存碎片的问题。对比CMS只是可怜的标记清除，在一些高qps场景的服务中，内存碎片化很严重，很容易造成Full Gc！
java堆在使用这两款回收器的时候，内存布局不同。在使用CMS收集器时，新生代和老年代是物理隔离的（为两个不同的连续的内存区域）。而用G1是对整个Heap
划分成若干个不同的Region，新生代和老年代是相互交叉的内存区域，是逻辑上的分类。这样划分的目的是规避每次在对象进行可达性分析都要在堆的全区域中进
行。比如一个Collection Set中的每个region都对应着一个Remembered set，G1可以维护这个Remembered Set，从中挑选出最具回收性价比的region进行回收，
G1嘛，就是Grabage First，提高回收效率。

G1优点，分代收集，不容易产生内存碎片化，一次回收比较彻底，不容易Full gc，并发标记，停顿时间相对可控（基于停顿时间和region占用大小判断是否有价
值回收）。

